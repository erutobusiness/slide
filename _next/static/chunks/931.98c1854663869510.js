"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[168,293,333,415,454,753,931,985],{333:(t,e,n)=>{n.d(e,{A:()=>i});let i={id:"04-quiz",title:"宣言的クイズ",description:"宣言的・命令的の違いをクイズで学ぶ",slides:[{id:"04-quiz-intro",title:"宣言的・命令的コードの判断基準を学ぶ",descriptions:["これらのクイズでは「宣言的」と「命令的」の違いを理解し、それぞれの特性やトレードオフについて考えよう","UIのほか、状態管理やデータフローの観点からも宣言的アプローチがどう役立つか考える"]},{id:"04-quiz-react",title:"JSXコードクイズ：どちらがより宣言的？",descriptions:["問題：以下の同じ機能を持つ2つのReactコンポーネントについて、どちらがより宣言的と言えるか？","カウンターの値が変わるとlocalStorageに保存し、値が閾値に達すると特別なメッセージを表示する"],codeExamples:[{title:"コードA",language:"jsx",code:"function VisitCounterA() {\n  const [count, setCount] = useState(() => {\n    return parseInt(localStorage.getItem(COUNT_KEY) || '0');\n  });\n  const [specialMessage, setSpecialMessage] = useState(() => {\n    const initialCount = parseInt(localStorage.getItem(COUNT_KEY) || '0');\n        return initialCount >= THRESHOLD ? '祝！初回から' + THRESHOLD + '回達成！' : '';\n  });\n  const handleIncrement = () => {\n    const newCount = count + 1;\n    setCount(newCount); // 1. 状態を更新\n    localStorage.setItem(COUNT_KEY, newCount.toString()); // localStorageに保存\n    if (newCount >= THRESHOLD && !specialMessage) {\n  setSpecialMessage('(A) 祝！' + THRESHOLD + '回達成！');\n    }\n  };"},{title:"コードB",language:"jsx",code:"function VisitCounterB() {\n  const [count, setCount] = useState(() => {\n    return parseInt(localStorage.getItem(COUNT_KEY) || '0');\n  });\n  const [specialMessage, setSpecialMessage] = useState('');\n  useEffect(() => {\n    localStorage.setItem(COUNT_KEY, count.toString());\n    if (count >= THRESHOLD) {\n      setSpecialMessage('祝！' + THRESHOLD + '回達成！');\n    }\n  }, [count]);\n  const handleIncrement = () => {\n    setCount(prevCount => prevCount + 1);\n  };"}],codeLayout:"horizontal"},{id:"04-quiz-react-answer",title:"解答例",descriptions:["コードBの方がより宣言的","コードBはuseEffectを使って、状態と副作用の関係を宣言的に記述している"],list:{groups:[{title:"コードA(命令的)の特徴",points:["handleIncrementでカウント更新と副作用を順に実行","「これらのステップを順番に実行せよ」と命令","状態更新と副作用が密接に結合"]},{title:"コードB(宣言的)のメリット",points:["handleIncrementは状態更新の意図のみを記述","useEffectで「countが変化したら副作用を実行せよ」と宣言","関心の分離：状態更新のトリガーと副作用の内容が分離"]}]}},{id:"04-quiz-yaml",title:"クイズ1：JSONとYAML、どちらがより宣言的？",descriptions:["問題：以下の2つのコード例のうち、どちらがより宣言的なアプローチと言えるか？"],codeExamples:[{title:"コードA：JSONを使用",language:"json",code:'{\n  "name": "declarative-ui-example",\n  "version": "1.0.0",\n  "dependencies": {\n    "react": "^18.2.0",\n    "react-dom": "^18.2.0",\n    "next": "^13.4.3"\n  }\n}'},{title:"コードB：YAMLを使用",language:"yaml",code:"name: declarative-ui-example\nversion: 1.0.0\ndependencies:\n  react: ^18.2.0\n  react-dom: ^18.2.0\n  next: ^13.4.3"}]},{id:"04-quiz-yaml-answer",title:"クイズ1の解答例",descriptions:["どちらも宣言的だが、YAMLの方がより人間に読みやすく、宣言性が体感しやすい場合がある"],list:{groups:[{title:"JSONのメリット",points:["広範な言語・ツールでサポート","パース処理が高速で効率的"]},{title:"YAMLのメリット",points:["人間が読み書きしやすい構文","コメントやマルチラインの扱いが豊富"]}]}},{id:"04-quiz-summary",title:"クイズのまとめ",descriptions:["実践的なコンポーネント開発では、状態ロジックをどのように整理するかが可読性とメンテナンス性に大きく影響する","useEffectパターンは状態と副作用の関係を宣言的に定義するための強力なツールである"]}]}},4415:(t,e,n)=>{n.d(e,{A:()=>i});let i={id:"02-why-now",title:"なぜ今宣言的UIなのか",description:"現代における宣言的UIの重要性",slides:[{id:"02-why-0",title:"生成AIを使いこなすには審美眼が重要だから",descriptions:["AIが生成するコードは、我々開発者が見定める必要がある","AI時代において、エンジニアはコードの品質や意図を理解し、適切に評価する能力が求められる","宣言的なコードは、意図や目的が明確であるため、AIの生成物を評価しやすい"]},{id:"02-why-1",title:"チーム開発での共通言語になるから",descriptions:["宣言的な考え方を理解していないと意図せずチームに負担をかけてしまう可能性がある","UI開発以外にも、IaC やデータクエリなど多様な分野で使われている宣言的な考え方は、\nチーム全体で共有しておくべき共通言語となりつつある"]},{id:"02-why-1-1",title:"チーム開発での共通言語になるから: 知らないと……",descriptions:["アンチパターンを産みやすい"],codeExamples:[{language:"jsx",code:'function ToggleButton() {\n  const handleClick = () => {\n    // グローバルな DOM クエリで要素を検索\n    const targetElement = document.querySelector("#target");\n    if (!targetElement) return;\n    // DOM要素の現在のクラスリストを直接確認して状態を判定\n    const isActive = targetElement.classList.contains("active");\n    // classList を直接操作してクラスを付け外し\n    targetElement.classList.toggle("active", !isActive);\n  };\n\n  return (\n    <>\n      <button id="target" onClick={handleClick}>Toggle Button</button>\n    </>\n  );\n}'}]},{id:"02-why-1-2",title:"チーム開発での共通言語になるから: 問題点",descriptions:["Reactを使っているのに、命令的なコードになっている"],codeExamples:[{language:"jsx",code:'function ToggleButton() {\n  const handleClick = () => {\n    // グローバルな DOM クエリで要素を検索\n    const targetElement = document.querySelector("#target");      // IDの衝突などで意図しない要素を操作する可能性がある\n    if (!targetElement) return;\n    // DOM要素の現在のクラスリストを直接確認して状態を判定\n    const isActive = targetElement.classList.contains("active");  // Reactの状態(useStateなど)を使わずにUIの状態を直接確認しているため、\n                                                                  // Reactが管理するUIと状態の同期が崩れてしまう可能性がある\n    // classList を直接操作してクラスを付け外し\n    targetElement.classList.toggle("active", !isActive);          // Reactの描画や状態更新の仕組みを無視してUIを直接操作すると、\n                                                                  // Reactが管理するUIと状態の同期が崩れてしまう可能性がある\n  };\n\n  return (\n        ...\n  );\n}'}]},{id:"02-why-1-3",title:"チーム開発での共通言語になるから: 解決策",descriptions:["ベストプラクティスに倣い、宣言的にする"],codeExamples:[{language:"jsx",code:'import { useState } from "react";\n\nfunction ToggleComponent() {\n  // 状態を定義\n  const [isActive, setIsActive] = useState(false);\n\n  return (\n    <>\n      <button\n        // 状態に基づいて className を宣言的に決定\n        className={isActive ? "active" : ""}\n        // 状態を更新\n        onClick={() => setIsActive(!isActive)}\n      >\n        Toggle Button\n      </button>\n    </>\n  );\n}'}]},{id:"02-why-2",title:"今のGUI技術の主要パラダイムだから",descriptions:["React, Vue, Flutter, SwiftUI など\n現代の主要なGUIフレームワークやライブラリは、\n宣言的UIをその核となる思想として採用している","UIが宣言的なアプローチで構造化されることで、\n状態と表示の対応関係が明確になりコードの見通しが良くなる"]},{id:"02-why-3",title:"様々なパラダイムや技術との親和性がいいから",descriptions:["宣言的アプローチは構造の明確化・可読性・再利用性を高めるため、\nあらゆる技術スタックや開発手法と親和性が高い"],codeExamples:[{language:"cobol",title:"COBOL: 命令的",code:'PERFORM VARYING I FROM 1 BY 1 UNTIL I > RECORD-COUNT\n  IF CUSTOMER-NAME(I)(1:1) = "A"\n    ADD 1 TO RESULT-INDEX\n    MOVE CUSTOMER-RECORD(I) TO RESULT-RECORD(RESULT-INDEX)\n  END-IF\nEND-PERFORM.'},{language:"sql",title:"SQL: 宣言的",code:"SELECT * FROM customers WHERE name LIKE 'A%';"}]},{id:"02-why-4",title:"なぜUIから始めたのか",descriptions:["(もちろん私がフロントエンドエンジニアだからなのもあるけど……)","UIは宣言的 vs 命令的の比較が視覚的に説明しやすく、\n特に学習者にとって理解の入口として有効だから"],image:{url:"/declarative/PXL_20250426_075656039.PORTRAIT.ORIGINAL.jpg",alt:"スマートフォンで撮影された縦向きの写真（宣言的UIに関するスライド用）"}}]}},5168:(t,e,n)=>{n.d(e,{A:()=>i});let i={id:"90-humanities",title:"人文学の視点から見る宣言的プログラミング",description:"宣言的プログラミングと人間の認知、言語、文化の関連性を探る",slides:[{id:"humanities-start",title:"番外編：人文学の視点から見る宣言的プログラミング",descriptions:["宣言的プログラミングは単なる技術的手法ではなく、人間の認知、言語、文化と深く関わる概念である","本章では言語学と人類学の観点から、宣言的表現の構造的特徴と人間の思考様式との関係を探求する"]},{id:"humanities-language-relativity",title:"言語相対性仮説と宣言的表現",descriptions:["言語が思考に影響を与えるとの仮説は、宣言的プログラミング言語の設計にも示唆を与える","宣言的言語は「何を」に集中し、命令的言語は「どのように」に焦点を当てる"],codeExamples:[{title:"SQL: 宣言的 - 「何が欲しいか」を明示",language:"sql",code:"SELECT name FROM users WHERE age > 18;"},{title:"JavaScript: 命令的 - 「どう取得するか」を指定",language:"javascript",code:"const adults = [];\nfor (const user of users) {\n  if (user.age > 18) {\n    adults.push(user.name);\n  }\n}"}]},{id:"humanities-cognitive-load",title:"宣言的言語と人間の認知負荷",descriptions:["宣言的言語は高レベルの抽象化を提供し、認知的な負荷を軽減することで問題領域の概念的理解を促進する"]},{id:"humanities-summary",title:"総括：学際的アプローチの価値",descriptions:["宣言的プログラミングを人文学の視点から分析することで、技術と文化の接点が見えてくる"]}]}},5293:(t,e,n)=>{n.d(e,{A:()=>i});let i={id:"03-history",title:"宣言的・命令的UIの歴史：コードの革命物語",description:"「どうやって」から「何を」へ — 宣言的プログラミングが世界を変えた物語",slides:[{id:"03-history-start",title:"黎明期：計算機に「考えさせる」という革命的アイデア",descriptions:["「機械に命令するのではなく、問題を教えて解かせる」という壮大な挑戦の始まり","ラムダ計算（1930年代）：「計算とは関数である」という革命的発想で、プログラミングの哲学的基礎を築く","命令型 vs 関数型の議論（効率 vs 抽象化）"]},{id:"03-history-1970s",title:"1970年代：Prolog 等の論理型言語が注目される",descriptions:["Prolog（1972年）: 「事実」と「ルール」を教えれば推論する魔法","制約プログラミング：条件を満たす解を見つけるだけで複雑な問題を解決","TeX（1978年）：フォーマットの手続きから解放し、意味を宣言する言語として注目"]},{id:"03-history-1980s",title:"1980年代：SQL が「何を欲しいか」を示す宣言に成功",descriptions:["SQL：SELECT * FROM users WHERE age > 20 のように、「何が欲しいか」だけを伝えるアプローチ","命令型だと同じ処理を何行も書くのに対して、宣言的は短く強力"]},{id:"03-history-1990s",title:"1990年代：HTML/CSS が一般公開され、宣言的表現が爆発的普及",descriptions:["HTML：表示を宣言することで、あらゆる環境で同じ見た目を実現","CSS：見た目の宣言言語としてデザインを表現"]},{id:"03-history-2000s",title:"2000年代：宣言的アプローチが実務の主流に",descriptions:["Scala, F#, Clojure などが実務で活躍し始める","Infrastructure as Code（Terraform 等）：サーバー構成を宣言することで自動的に再現"]},{id:"03-history-2010s",title:"2010年代：React の衝撃 — UI はただの関数",descriptions:["React（2013年）: UIはただの関数 f(state) = view という発想が普及","Virtual DOM による効率的な差分更新で宣言的UIが一般化"]},{id:"03-history-now",title:"現代：宣言的アプローチが自己修復する世界へ",descriptions:["AI 時代の宣言的プログラミング：要求を伝えればAIが最適な実装を提案","Kubernetes の Desired State や GitOps のように、宣言的に望む状態を定義する運用が普及"]},{id:"03-history-summary",title:"宣言的プログラミングの旅：過去から未来へ",descriptions:["「何を」だけを伝えれば機械が最適な手続きを実行してくれる、という単純な発想が世界を変えた","UIからインフラまで、宣言的アプローチは幅広い分野で価値を発揮している"],image:{url:"/declarative/PXL_20250430_135602763.PORTRAIT.ORIGINAL.jpg",alt:"縦向きの写真（歴史スライドの挿絵）"}}]}},5753:(t,e,n)=>{n.d(e,{A:()=>i});let i={id:"05-letter",title:"宣言的UIのこぼれ話（お便り形式）",description:"宣言的UIに関するよくある疑問や誤解について解説",slides:[{id:"05-letter-1",title:"お便り1：宣言的UIはパフォーマンスが悪い？",descriptions:["疑問：「宣言的UIは内部で多くの処理が行われるため、命令的UIより遅いのでは？」","回答：","・確かに初期のフレームワークではオーバーヘッドがあった","・しかし現代のフレームワークは差分検知アルゴリズムやコンパイラ最適化で高速化されている","・命令的に最適化された手書きコードより遅いケースもあるが、保守性や可読性の向上を考慮すれば総合的なコストは低下することが多い"]},{id:"05-letter-2",title:"お便り2：宣言的UIは学習コストが高い？",descriptions:["疑問：「新しい概念や抽象化が多く、習得が難しいのでは？」","回答：","・確かに最初の学習曲線は存在する","・しかし「状態に基づいてUIが決まる」という単純な概念を理解すれば、異なるフレームワーク間の知識移転は容易"]},{id:"05-letter-3",title:"お便り3：宣言的UIとReactは同じもの？",descriptions:["疑問：「宣言的UIってReactのことなの？」","回答：","・Reactは宣言的UIを代表する実装の1つだが、同じではない","・Vue, Svelte, SwiftUI, Flutter, Compose なども宣言的UIのフレームワークであり、それぞれ独自のアプローチを持つ"]}]}},5985:(t,e,n)=>{n.d(e,{A:()=>i});let i={id:"01-intro",title:"宣言的UIとは？",description:"宣言的UIの基本概念について解説",slides:[{id:"01-intro-1",title:"宣言的UIとは",descriptions:["宣言的UIとは「何を」表示するかを記述し、「どのように」表示するかの詳細はフレームワークに任せるアプローチ","状態という入力からUIを出力し、状態変化に応じた更新はフレームワークが自動的に行う","UIの構造や見た目を、どう作るのかの手順を記述する（命令的）のではなく、状態に基づいて定義する（宣言的）スタイル"],image:{url:"/declarative/宣言的UI.png",alt:"「宣言的UI」の概念を示す図（日本語の見出し付き）"}},{id:"01-intro-example",title:"よくある例え（車もってないけど……）",descriptions:["命令的：マニュアル車の運転のように、ギアの切り替えやクラッチ操作など、すべての手順を自分で制御する必要がある","宣言的：オートマ車の運転のように、「前に進む」「止まる」といった目的を伝えるだけで、内部の操作は車が自動で行う"],tweetUrl:"https://x.com/gethackteam/status/1268892357027663873"},{id:"01-intro-code",title:"コード比較：カウンターボタンの実装",descriptions:["同じ機能（ボタンクリックでカウントアップ）を命令的UIと宣言的UIで実装した例を比較して、アプローチの違いを明確にしてみる"],codeExamples:[{title:"命令的UI（JavaScript DOM）",language:"javascript",descriptions:["DOM要素を直接操作して内容を変更","状態（count変数）の更新とDOMの更新を明示的に記述","「どのように」UIを更新するかの手順に焦点を当てている"],code:"// HTML: <button id=\"counter\">0</button>\n\nfunction setupCounter() {\n  const button = document.getElementById('counter');\n  let count = 0;\n\n  button.addEventListener('click', () => {\n    // 状態の更新\n    count++;\n\n    // DOM要素の更新\n    button.textContent = count;\n  });\n}"},{title:"宣言的UI（React）",language:"jsx",descriptions:["状態(count)の変更がUIの更新を自動的にトリガー","setCount関数で状態を更新するだけでボタンの表示も自動的に更新","「何を」表示するかを記述し、DOMの更新処理はReactが担当"],code:"function Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <button onClick={() => setCount(count + 1)}>\n      {count}\n    </button>\n  );\n}"}],codeLayout:"horizontal"},{id:"01-intro-merits",title:"両アプローチの選び方",descriptions:["「正しい」アプローチはなく、状況によって適切な選択が変わる","現代のフレームワークは宣言的な書き方で、内部では効率的な命令的更新を行っている"],list:{groups:[{title:"命令的UIを選ぶとき",points:["\uD83C\uDFAE 精密な制御が必要（複雑なアニメーションなど）","⚡ 極限のパフォーマンス最適化が必要","\uD83D\uDCDA 既存のDOM APIと直接やり取りする必要がある","\uD83D\uDD0D 特定の要素だけを細かく操作したい"]},{title:"宣言的UIを選ぶとき",points:["\uD83E\uDDE9 複雑なUIをシンプルに管理したい","\uD83D\uDD04 頻繁に変わる状態とUIの同期を保ちたい","\uD83D\uDC65 チーム開発で一貫性を保ちたい","♻️ コンポーネントを再利用したい"]}]}}]}},8454:(t,e,n)=>{n.d(e,{A:()=>i});let i={id:"06-summary",title:"まとめ",description:"宣言的UIのコンセプトと重要ポイントの復習",slides:[{id:"06-summary-1",title:"宣言的UIの要点",descriptions:["1. 状態（データ）に基づくUI設計：UI = f(state)","2. 「何を」表示するかを記述し、「どのように」はフレームワークが担当","3. 再利用可能なコンポーネントによる抽象化","4. 自動的なUI更新によるDOMとの同期"]},{id:"06-summary-2",title:"宣言的UIの利点",descriptions:["・コードの可読性と保守性の向上","・状態の単一管理による予測可能性","・テストの容易さ","・宣言的考え方は他分野（IaC, AI連携など）にも応用可能"]},{id:"06-summary-3",title:"次のステップ",descriptions:["・異なるフレームワークを比較してみる","・ReactやVueなどのフレームワークで実装練習","・状態管理ライブラリ（Redux, Vuex, Recoil）について学ぶ"],codeExamples:[{language:"jsx",code:"// 宣言的UIの基本形\nfunction App() {\n  const [state, setState] = useState(initialState);\n\n  return (\n    <UI based on state />\n  );\n}"}]}]}},9931:(t,e,n)=>{n.d(e,{slideSections:()=>d});var i=n(5985),s=n(4415),o=n(5293),a=n(333),c=n(5753),l=n(8454),r=n(5168);let d=[i.A,s.A,o.A,a.A,c.A,l.A,r.A]}}]);